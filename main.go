package main

import (
	"AAA/curve25519"
	"AAA/implementation/bls"
	"AAA/implementation/elgamal"
	"AAA/implementation/mabe"
	"bytes"
	"fmt"
	"log"
	"math/big"
	"time"

	"github.com/fentec-project/gofe/data"
	"github.com/fentec-project/gofe/innerprod/simple"
	"go.dedis.ch/kyber/v3"
	"go.dedis.ch/kyber/v3/pairing/bn256"
	"go.dedis.ch/kyber/v3/util/random"
)

func testBLSSignature() {
	msg := []byte("Hello Boneh-Lynn-ShachamHello Boneh-Lynn-ShachamHello Boneh-Lynn-ShachamHello Boneh-Lynn-ShachamHello Boneh-Lynn-ShachamHello Boneh-Lynn-ShachamHello Boneh-Lynn-ShachamHello Boneh-Lynn-ShachamHello Boneh-Lynn-ShachamHello Boneh-Lynn-ShachamHello Boneh-Lynn-ShachamHello Boneh-Lynn-ShachamHello Boneh-Lynn-ShachamHello Boneh-Lynn-ShachamHello Boneh-Lynn-ShachamHello Boneh-Lynn-ShachamHello Boneh-Lynn-ShachamHello Boneh-Lynn-ShachamHello Boneh-Lynn-Shacham")
	suite := bn256.NewSuite()
	private, public := bls.NewKeyPair(suite, random.New())
	// s, _ := private.MarshalBinary()
	// fmt.Println(len(s))
	sig, err := bls.Sign(suite, private, msg)
	if err != nil {
		fmt.Println(err)
		return
	}
	for i := 0; i < 100; i++ {
		bls.Verify(suite, public, msg, sig)
	}
	// fmt.Println(sig)
	// err = bls.Verify(suite, public, msg, sig)
	// if err != nil {
	// 	fmt.Println(err)
	// 	return
	// }
}

func testThresholdElGamal() {
	// now := time.Now()
	suite := curve25519.NewBlakeSHA256Curve25519(false)
	t := 5
	n := 30
	masterSecretKey, masterPublicKey := elgamal.NewKeyPair(suite, random.New())
	keyPairs := elgamal.GenerateKeyPair(suite, t, n, masterSecretKey)
	msg := []byte("hello")
	// fmt.Println(time.Since(now))
	c1, c2, err := elgamal.Encrypt(suite, masterPublicKey, msg)

	if err != nil {
		log.Println(err)
	}

	// msg3, err3 := elgamal.Decrypt(suite, rp, cipher, keyPairs[0].SecretKey)
	// if err3 != nil {
	// 	log.Println(err3)
	// }
	// result3 := bytes.Compare(msg, msg3)
	// if result3 == 0 {
	// 	log.Println("true")
	// } else {
	// 	log.Println("false")
	// }

	var subPoints []kyber.Point
	var xs []int

	for i := 0; i < t; i++ {
		// compute u:=secretKey*rp
		u, err := elgamal.Deal(suite, c2, keyPairs[i].SecretKey)
		if err != nil {
			log.Println(err)
			return
		}
		subPoints = append(subPoints, u)
		xs = append(xs, keyPairs[i].X)
	}
	now1 := time.Now()
	for i := 0; i < 100; i++ {
		elgamal.ThresholdDecrypt(suite, subPoints, xs, c1)
	}
	fmt.Println("descryption cost:", time.Since(now1)/100)
	msg2, err2 := elgamal.ThresholdDecrypt(suite, subPoints, xs, c1)

	if err2 != nil {
		log.Println(err2)
	}
	result := bytes.Compare(msg, msg2)
	if result == 0 {
		log.Println("true")
	} else {
		log.Println("false")
	}

}

// anonymous identity generation
// t=10, n = 30: 25ms;
// t=15, n = 30: 25ms;
// t=20, n = 30: 28ms;
// t=25, n = 30: 30ms;
// t=30, n = 30: 30ms
// t=5, n = 7: 2ms 18ms
// t=5, n = 10: 9.3ms
// t=5, n = 13: 10.1ms
// t=5, n = 16: 11.8ms
// t=5, n = 20: 13.5ms

func main() {
	// testBLSSignatureLength()

	// MABETest()

	// total := time.Duration.Abs(0)
	// for i := 0; i < 1; i++ {
	// 	start := time.Now()
	// 	MABETest()
	// 	cost := time.Since(start)
	// 	total = total + cost
	// }

	// fmt.Println(total / 100)

	// total := time.Duration.Abs(0)
	// for i := 0; i < 1; i++ {
	// 	start := time.Now()
	// 	testBLSSignature()
	// 	cost := time.Since(start)
	// 	total = total + cost
	// }
	// fmt.Println(total)
	// total := time.Duration.Abs(0)
	// for i := 0; i < 1; i++ {
	// 	start := time.Now()
	// 	cost := time.Since(start)
	// 	total = total + cost
	// }

	// fmt.Println(total / 100)

	// err := bls.ThresholdBLS(5, 20)
	// if err != nil {
	// 	fmt.Println(err)
	// }
	// now := time.Now()
	// for i := 0; i < 1; i++ {
	// 	testThresholdElGamal()
	// }

	// fmt.Println(time.Since(now) / 1)
	// now := time.Now()
	// for i := 0; i < 100; i++ {
	// 	testThresholdElGamal()
	// }
	// cost := time.Since(now)
	// fmt.Println(cost / 100)

	// testThresholdElGamal()
	MABETest()
}

func test2() {
	// Instantiation of a trusted entity that
	// will generate master keys and FE key
	l := 2                  // length of input vectors
	bound := big.NewInt(10) // upper bound for input vector coordinates
	modulusLength := 2048   // bit length of prime modulus p
	trustedEnt, _ := simple.NewDDHPrecomp(l, modulusLength, bound)
	msk, mpk, _ := trustedEnt.GenerateMasterKeys()

	y := data.NewVector([]*big.Int{big.NewInt(1), big.NewInt(2)})
	feKey, _ := trustedEnt.DeriveKey(msk, y)

	// Simulate instantiation of encryptor
	// Encryptor wants to hide x and should be given
	// master public key by the trusted entity
	enc := simple.NewDDHFromParams(trustedEnt.Params)
	x := data.NewVector([]*big.Int{big.NewInt(3), big.NewInt(4)})
	cipher, _ := enc.Encrypt(x, mpk)

	// Simulate instantiation of decryptor that decrypts the cipher
	// generated by encryptor.
	dec := simple.NewDDHFromParams(trustedEnt.Params)
	// decrypt to obtain the result: inner prod of x and y
	// we expect xy to be 11 (e.g. <[1,2],[3,4]>)
	xy, _ := dec.Decrypt(cipher, feKey, y)
	print(xy)
	print("123")
}

func MABETest() {
	inst := mabe.NewMAABE()
	auditor, err := inst.InitAuditor(false)
	if err != nil {
		fmt.Println(err)
	}
	auth1, err := inst.NewMAABEAuth("auth1", []string{"America", "China", "France", "Britain"})
	if err != nil {
		fmt.Errorf("generating auth1 faces error!")
	}
	auth2, err := inst.NewMAABEAuth("auth1", []string{"Computer", "Math", "English", "Physics"})
	if err != nil {
		fmt.Errorf("generating auth1 faces error!")
	}

	pub1 := auth1.PubKeys()
	pub2 := auth2.PubKeys()

	// // 生成主密钥 和 公共密钥
	// pubKey, secKey, err := inst.GenerateMasterKeys()
	// fmt.Printf("pubKey.PartGT: %v\n", pubKey.PartGT)
	// if err != nil {
	// 	panic(err)
	// }
	// 明文数据信息
	msg := "i am tony"

	// 构造策略信息
	// "((0 AND 1) OR (2 AND 3)) AND 5",
	msp, err := mabe.BooleanToMSP("((America AND Physics) OR (China AND English) )", false)
	if err != nil {
		panic(err)
	}

	cipher, err := inst.Encrypt(msg, msp, []*mabe.MAABEPubKey{pub1, pub2})
	if err != nil {
		panic(err)
	}
	// cipherLength := 0

	decKey1, err := auth1.GenerateAttribKeys("edge server1", []string{"America", "France"})
	if err != nil {
		panic(err)
	}
	decKey2, err := auth2.GenerateAttribKeys("edge server1", []string{"Physics", "English"})

	if err != nil {
		panic(err)
	}

	msgCheck, err := inst.Decrypt(cipher, append(decKey1, decKey2...))
	if err != nil {
		panic(err)
	}

	fmt.Println(msgCheck)

	msgCheck2, err := inst.Audit(cipher, auditor.SK)
	if err != nil {
		panic(err)
	}

	fmt.Println(msgCheck2)
}
